# 线程安全Syncchronized

## 并发的两个关键问题

1、线程之间如何通信

　　通信是指线程之间以何种机制来交换信息，在命令式编程中，通信机制有两种：**共享内存和消息传递**；JAVA的并发采用的是共享内存，线程之间的通信总是隐式进行。

2、线程之间如何同步

　　**同步指程序中用于控制不同线程间操作发生相对顺序的机制**，在共享内存并发模型中，同步是显式进行的。

## JAVA的内存模型
参考 浅谈JMM

#### 重排序

重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。重排序分为3类：

1、编译器优化重排序：编译器在不改变单线程语义的前提下，可以重新安排语句的执行顺序。

2、指令级并行的重排序：如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。

3、内存系统重排序：由于处理器使用缓存和缓冲区，使得加载和存储操作看上去可能是乱序执行。

从Java源代码到最终实际执行的指令序列，会经过下面三种重排序：

##### 数据依赖性：

```
a = 1;     //1
a = 2;    //2
```

上面展示的是写后写的操作，其中1、2两步的顺序打乱，会改变程序执行的结果；这种就是数据有依赖性性。

```
double pi = 3.14;             //A
double r = 1.0;               //B
double area = pi * r * r;     //C
```

这里可以看到，A和C、B和C有数据依赖，其中A和B没有数据依赖，这样编译器和处理器就可以对AB进行重排序。

上面AB这种场景就是符合as-if-serial语义的：不管怎么进行重排序，单线程程序的执行结果不能被改变。编译器和处理器在重排序的时候都必须遵守as-if-serial语义。

#### 内存屏障

内存屏障又称内存栅栏，是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。由于现在操作系统都是多处理器，而每一个处理器都有自己的缓存，并且这些缓存都不是实时与内存进行交互。这样就会导致不同CPU上缓存的数据不一致问题，在多线程的程序中，就会出现一些异常行为。而操作系统底层就提供了内存屏障来解决这些问题。

#### volatile内存语义与实现

1、可见性
volatile不能保证原子性，参考VolatileTest
2、禁止指令重排序优化
happens-before

 
## 作用

同步方法支持一种简单的策略来防止线程干扰和内存一致性错误：如果一个对象对多个线程可见，则该对象变量的所有读取或写入都是通过同步方法来完成的。
通俗来说就是：能够保证在同一时刻最多只有一个线程执行该代码（串行化），以达到保证并发安全的效果。

错误举例：两个线程同时i++，最后结果会比预期少

## 对象锁类锁

#### 对象锁
包括**方法锁**（默认锁对象为this当前实例对象）
和**同步代码块锁**（自己指定锁对象）。

#### 类锁
指Synchronized修饰**静态**的方法
或指定锁为**Class对象**。

## 性质

#### Synchronized可重入性质

加锁次数计数器

* 什么是可重入：指的是同一线程的外层函数获得锁之后，内层函数可以直接再次获取该锁，而不是释放当前的锁去重新获取一个锁，这是它的一个优点

* 好处：避免死锁，提升封装性

* 粒度：是线程范围而非调用范围

　　情况一：同一个方法是可以重入的
　　情况二：不同方法是可以重入的
　　情况三：不同类是可以重入的（父子类）

#### Synchronized不可中断

一旦这个锁已经被别人获得了，如果我还想获得，我只能等待或者阻塞，直到别人释放这个锁，如果别人永远不释放锁，那么我只能永远等待下去，这是一个缺点

相比之下Lock类拥有中断的能力，如果我等的时间太长了，有权中断正在执行的线程，如果不想等了，可以退出。

 不够灵活，加锁和释放锁单一，每个锁仅有单一的条件（某个对象），可能是不够的

无法知道是否成功获取到锁

## 可见性原理

JMM，Java内存模型

线程交叉执行，重排序的叠加，共享变量未及时更新

解决方案：原子性+可见性

volatile可以实现可见性（内存屏障禁止重排序），不能保证原子性

## 7种情况
思路：将问题转化为是否获取同一个令牌

1.两个线程同时访问一个对象的同步方法 （等待）
2.两个线程访问的是两个对象的同步方法 （同时）
3.两个线程访问的是synchronized的静态方法 （等待）
4.同时访问同步方法和非同步方法 （同时）
5.访问同一个对象的不同的同步方法 （等待）
6.同时访问静态synchronized和非静态synchronized方法 （同时）
7.方法抛出异常后，会释放锁

## 总结

synchronized是一种悲观锁：

1、多线程竞争的情况下，频繁的加锁解锁导致过多的线程上下文切换，由于java线程是基于操作系统内核线程实现的，所以如果阻塞或者唤醒线程都需要切换到内核态操作，这会极大的浪费CPU资源。

2、一个线程持有锁，会导致后面其他请求该锁的线程挂起（独享所，互斥锁）。

3、效率低，不够灵活，无法获知获取状态

synchronized锁优化：自旋锁

很多应用中共享数据的锁定，只会持续很短的时间，如果因为这很短的时间做线程的挂起和恢复，会造成很大的性能消耗（因为java线程对应操作系统的内核线程），让当前线程不停地的在循环体内执行不被挂起，这就是自旋锁的实现，后面会展开详细介绍。

一把锁（**对象锁**）只能同时被一个线程获取，没有拿到锁的线程只能等待（对应1、5的情况）。
每个实例都对应有自己的一把锁，不同实例之间互相影响；（令牌）

所对象是*.class和synchronized修饰的是static方法的时候，所有对象共有同一把**类锁**。（对应2、3、4、6的情况）。
无论正常执行还是抛出异常，都会释放锁（对应7的情况）。

锁对象不能为空、作用域不宜过大（代码块）、避免死锁
如何选择Lock和synchronized关键字?
答：优先使用synchronized，如果需要灵活的加解锁机制，用到Lock中的方法，比如lock()、unlock()等，再选择使用Lock.

在一个被synchronized修饰的方法里面调用了一个没有被synchronized修饰的方法线程安全吗？
答案是不安全，因为synchronized只对修饰自身的方法起作用，对其他方法不起作用。

