设计模式-刘伟（中南大学博士）

【设计模式概述】
招式：IDE，开发技术JSP,thymeleaf,各种框架技术
内功：数据结构，算法，设计模式，重构，软件工程
设计模式：问题-->约束条件-->解决方案（关联解法+其他相关模式）-->优缺点
根据用途分类：创建型，结构型，行为型
作用：避免重复造轮子，交流沟通，可重用可扩展，便于他人理解，深入理解OOP

【面向对象设计原则】

-粒度控制（实现松耦合的前提）
单一职责:一个模块类或方法承担的责任越大越多就越难复用，高内聚低耦合
接口隔离：接口尽量细化，方法尽量少

-兼而有之
合成复用(组合)：白箱复用继承会破坏封装性（耦合度高）,黑箱复用耦合度低，HAS-A与IS-A区别是判定原则。多组合少继承

-松耦合
开闭：对扩展开放，对修改关闭，是目标，抽象化时开闭的关键
代换：实现开闭原则的重要方式之一
依赖倒转：针对接口编程而不是实现，是实现开闭的手段
最小知识：限制通信的宽度和深度，通过引入合理的第三方来降低耦合度

-总结
核心思想是灵活多变，根据具体的场景采取合适的方案，上善若水
粒度划分合理就方便复用，松耦合有利于后期的修改扩展

【创建型】

简单工厂：
工厂+抽象产品-->具体产品
引入第三方
由指定工厂来创建，屏蔽了创建细节，创建的实例具有共同的父类。消灭if...else if...else代码块，以设计原则来考量。
从手动new来创建，到从工厂来创建，返回值是父类抽象类基类。对象的创建和使用相分离

工厂方法：
抽象工厂-->具体工厂+抽象产品-->具体产品
引入第三方
产品、工厂均有抽象层，选择了特定的工厂实现也就确定了特定的产品实现（具体工厂具体产品一一对应，对于多态的运用）。

抽象工厂：
抽象工厂-->具体工厂+抽象产品(多个)-->具体产品
引入第三方
具有多个不同分类的产品，每个分类还有细分实现，选择特定的工厂实现可以生产一个产品族（从不同类型中各挑选构成），主题切换。

单例：
只有一个实例，自行创建这个实例，自行向整个系统提供实例
饿汉式、懒汉式延迟加载，双重检查锁定，volatile只可保证可见性，IoDH技术虚拟机来保证线程安全
节约资源，职责过重

原型：
抽象原型类-->具体原型类+客户端
Cloneable标识接口，同类型不同实例，浅克隆深克隆区别在于是否支持引用类型成员变量的复制，原生为浅克隆
可以通过序列化及反序列化实现深克隆，Serializable标识接口
创建成本较小时直接构建新实例

建造者：
产品+抽象建造者-->具体建造者+指挥者
指挥者充当引入的第三方松耦合
指挥者调用建造者对象的部件构造与装配方法，完成复杂对象的构造，可以增加钩子方法进行精细控制
建造者对比抽象工厂：
建造者侧重装配一个复杂的完整的对象，更关心建造过程，如生产车间；
抽象工厂关注产品整体忽视细节，如工厂整体功能

【结构型】

适配器(包装器Wrapper)：
对象适配器 目标类+适配器类+适配者类 关联关系
引入第三方
类适配器 继承关系
双向适配器
缺省适配器模式 适配者接口+缺省适配器类+具体业务类
转换器，适配器可以适配多个适配者对象

桥接：
抽象类-->扩充抽象类+某维度接口-->某维度具体实现类
建立某维度的抽象层，通过抽象关联取代多层继承
将N维特征中的N-1维作为剩下1维度的属性，通过属性来强化组装主体的能力，其中采用面向抽象接口编程
桥接和适配器可以在不同时期结合使用，也一开始就联用

组合：
抽象构件-->叶子构件，容器构件
构建统一的抽象层
透明组合模式-抽象构件声明了所有用于管理成员对象的方法
安全组合模式-抽象构件无管理成员对象的方法
实现对叶子对象和容器对象操作的统一，实现递归操作，部分-整体模式

装饰：
抽象构件-->具体构件+抽象装饰类-->具体装饰类
引入第三方
实现功能复用采用关联而非继承 
无须定义子类实现对对象动态增加职能（对单个对象赋能）
透明装饰模式 完全针对抽象编程
半透明装饰模式 不能多次装饰
装饰对比桥接：
桥接在于拆分维度剥离功能，装饰在于赋能强化功能

外观(门面)：
抽象外观类-->具体外观角色+子系统角色
引入第三方
为子系统中一组接口提供一个统一的入口，并不增加新功能，只是简化调用接口
类似于Service层，为上层提供一个入口
对比建造者：
提供便捷入口（如同一个门面）；建造者侧重如何指挥调度配置生产一个复杂的产品

享元：
抽象享元-->具体享元，非共享元素类+享元工厂
以共享的方式高效地支持大量细粒度对象的重用
带外部状态的解决方案 
单纯享元模式 复合享元模式（可分解为单纯享元模式）
享元对比单例：
单例侧重节约空间提高性能；享元侧重共享数据

代理：
抽象代理-->具体代理+真实对象
引入第三方
提供一个代理或者占位符，有代理对象来控制对原对象的访问（屏蔽对实际对象的访问，无法直接访问或者直接访问困难）
远程、虚拟、保护、缓冲、智能引用
代理对比装饰：
使用代理模式，代理和真实对象之间的的关系通常在编译时就已经确定了（对客户隐藏了一个对象的具体信息），
而装饰者能够在运行时递归地被构造（通常将原始对象作为一个参数传给装饰器的构造函数）。
代理对比适配器：
适配器重在转换对旧接口的访问；代理重在隐藏实现，做一些额外工作

【行为型】

职责链：
抽象处理者-->具体处理者
建立统一抽象层
发送者接收者松耦合，多个对象都有可能接收对象
职责链模式并不创建职责链，创建工作由其他部分功能完成
纯职责 与 不纯职责（事件浮升机制）
优点-无需知道被谁处理，处理对象只需维持一个后继引用，可动态修改职责链，符合开闭
缺点-可能得不到处理，性能影响，循环调用

命令：
调用者+抽象命令类-->具体命令类+接收者
引入第三方
将一个请求封装为一个对象，支持参数化客户，请求排队
命令队列，无严格先后顺序可结合多线程技术（批处理）
Undo操作：逆向操作，或者备忘录模式
宏命令
优点-松耦合，符合开闭，多用途
缺点-过多的具体命令

解释器：
抽象表达式-->终结表达式，非终结表达式+环境类
定义一个语言的文法，建立解释器来解释该语言的句子

迭代器：
抽象迭代器-->具体迭代器+抽象聚合类-->具体聚合类
提供一种方法来访问聚合对象，而不暴露对象的内部表示，别名为游标
数据存储与数据遍历分离
优点-支持不同的方式遍历聚合对象，简化了聚合类
缺点-增加了复杂性，设计难度较大

中介者：
抽象中介者-->具体中介者+抽象同事类-->具体同事类
引入第三方，注册登记
用一个中介对象来封装一系列的对象交互，网状结构转星型形结构
中转作用+协调作用
优点-从多对多到一对多，松耦合，可重用，单一职责
缺点-终结者类可能会非常复杂

备忘录：
原发器+备忘录+负责人
不破坏封装的前提下捕获并在外部保存这个状态，并可以将对象恢复到该状态
优点-状态恢复机制，对信息的封装
缺点-消耗资源

观察者：
主题目标（抽象或者接口）-->具体主题目标+抽象观察者-->具体观察者
注册登记
一对多依赖关系，发布订阅，模型视图模式，源监听器模式，从属者模式
MVC模式中，模型数据即为目标，视图对应于观察者，控制器充当中介者
优点-表示层与数据逻辑层的分离，抽象耦合，广播通信，满足开闭
缺点-循环依赖，观察者过多时耗时较长

状态：
抽象状态类-->具体状态类+环境类
允许一个对象在内部状态改变时改变它的行为
优点-封装了转换规则，与状态相关的行为集中化，避免多重条件选择
缺点-对象的个数，对开闭支持支持不好
对比工厂方法：
工厂创建对象，解决资源的创建；策略注重算法的封装与独立，都用到了多态和依赖倒转

策略：
抽象策略-->具体策略+环境类
将算法的定义与使用分开，使算法可以相互无缝替换（对于多态的运用），可插入式算法
优点-支持开闭，单一职责，替代继承关系的办法，避免多重条件选择语句，一种复用机制
缺点-必须要了解算法，很多具体策略类，无法同时使用

模板方法：
抽象类-->具体子类
基本方法-抽象方法，具体方法，钩子方法
定义一个算法框架，将一些步骤延迟到子类实现（抽象类是半成品，子类完善）
优点-延迟实现，复用代码鼓励恰当的继承，反向控制，单一开闭
缺点-可变方法过多导致类过多

访问者：
抽象元素-->具体元素+抽象访问者-->具体访问者+对象结构
提供作用于某对象结构中各元素的操作表示，不改变各元素类的定义的前提下定义作用于这些元素的新操作
双重分派，对开闭支持的倾斜性
组合模式+访问者模式
优点-新增访问操作很方便，职责更清晰
缺点-新增元素困难，破坏封装
