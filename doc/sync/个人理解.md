##问题引出
多线程i++计算结果错误
实质为操作分为读写两个阶段，两个操作读取的值相同，但计算应该基于前一个写操作的结果
CAS解决方案可类比数据库的如果满足条件就更新数据的SQL
推而广之，多线程运行操纵同一个数据对象时，需要满足一个或者一组操作需要作为一个整体运行（原子性），若不满足则会出现错误

##关键点
问题的核心在于多个线程共享同一项数据，若操纵不同的实例则不存在该问题，ThreadLocal即是如此
所有的操作都有一定的前提条件，在多线程的环境下，一个线程基于一定情况计算好如何处理时另一线程已经将前提条件给更新了，此前的计算应该作废，继续执行则错误产生

##解决方案
简单的方案就是完全串行化，但多线程本身的目的就在于充分地利用资源，这是自相矛盾的
折中的结果是部分代码或者功能串行化，等效于需要授权，需要权限，不是能随意获取执行的

可参考的现实世界的应用场景就是排队

####令牌
尝试加锁的效果等同于申请唯一的令牌，令牌即执行的许可
解锁等效于释放令牌

未加锁的方法或对象无需令牌
对象锁以当前实例为令牌
类锁以类作为令牌

####公平性
获取令牌分配令牌就涉及如何分配的问题？即公平性
公平即先到先得

## ThreadLocal
threadLocal.get()方法实质的操作是Thread.currentThread().threadLocals.getEntry(this)
即数据实际存储在当前线程中，不存在线程安全问题
key值为当前threadLocal引用，可以使用多个ThreadLocal实例
